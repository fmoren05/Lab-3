# Lab 3
 
![image5 (1)](https://github.com/fmoren05/Lab-3/assets/156385950/5790b164-8e17-496b-a8a5-679f597b72d1)

The purpose of Lab 3 was to develop a closed-loop proportional controller that utilizes the encoder developed in Lab 2 and the motor controller developed in Lab 1 to run step response tests with different proportional gains and setpoints. A GUI similar to that of Lab 0 was also implemented so that the user can manually enter values for Kp and the setpoint. Running tests through the GUI also results in plots of the response with time in seconds on the x-axis and position in encoder counts on the y-axis. The GUI file interacts directly with our main file source code, which then communicates to all other files used for this Lab. Our closed-loop response source code does what is described by the block diagram in Canvas for the Lab. The closed-loop file takes in the encoder value setpoint as an input and takes the difference between the actual encoder value (initially 0) and the setpoint to calculate the error. Once the error is obtained, it is multiplied by our controller gain (Kp value) to produce a percent duty cycle input for our PWM to use when running the motor. This will cause a change to our measured output since the encoder reader would have read a new value for the current position. This new value is then used to calculate the new error and run the same process described in a loop until the measured output is at or close enough to the setpoint. The gain values used are relatively small decimal numbers because high-value gains will cause the controller to overshoot and oscillate about the setpoint value. Therefore, since our gain is relatively small, obtaining a small error when approaching the setpoint will result in a much smaller product when they are multiplied by each other. This results in a small PWM percent duty cycle being entered, which eventually results in the motor coming to a stop. To utilize our closed-loop using step response tests, we set up a loop in our main file that set a limit for the number of iterations that the controller was run for to 25 iterations. Therefore, regardless of whether or not the controller was able to get the motor to the setpoint value, it would stop running after 25 readings. Each iteration is also set to occur roughly every 10ms as requested by the instructions. This used to properly space our readings. When the step response is complete, we print the results for the encoder reading at each time interval and use those readings to generate our plot.

The plot above was produced using our GUI file. It contained three separate lines to show the response for an underdamped performance (Blue), an excessive oscillation performance (Green), and the best response we could achieve (Orange). All tests used a setpoint of 50,000 with different Kp input values. We used a Kp value of 0.001 for the underdamped response, 0.05 for the excessive oscillation response, and 0.003 for the best response achieved. The Kp value of 0.001 produced a line that never reached the setpoint in the time allowed by the step response. The excessive oscillation response resulted in a line that shot up to the setpoint but oscillated about it due to the overshoot resulting from a high gain value. The best response achieved shot up to the setpoint and hit a steady state without any overshoot. It is important to note that the best response was slightly below the setpoint despite reaching a steady state.
